<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Archives - Page 129</title><link rel="stylesheet" type="text/css" href="http://dev.dxprog.com/dxprog.github.io/docs/static/css/index.css"/></head><body><section class="rollup-page"><section class="intro-bar"><img src="http://dev.dxprog.com/dxprog.github.io/docs/static/images/me.jpg" alt="Matt Hackmann" class="intro-bar__photo"/><h1 class="intro-bar__header"><span class="intro-bar__name intro-bar__name--first">Matt</span><span class="intro-bar__name intro-bar__name--last">Hackmann</span></h1><h2 class="intro-bar__subhead">The thoughts and goings-on of some programmer dude.</h2><nav class="intro-bar__social-nav"><ul class="social-links"><li class="social-links__item"><a class="social-links__link social-links__link--rss" target="_blank" href="http://feeds.feedburner.com/dxprog">RSS Feed</a></li><li class="social-links__item"><a class="social-links__link social-links__link--github" target="_blank" href="https://github.com/dxprog">GitHub</a></li><li class="social-links__item"><a class="social-links__link social-links__link--twitter" target="_blank" href="https://twitter.com/dxprog">Twitter</a></li><li class="social-links__item"><a class="social-links__link social-links__link--linkedin" target="_blank" href="https://www.linkedin.com/in/mhackmann">LinkedIn Profile</a></li></ul></nav></section><section class="article-list"><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/ajax-and-the-user-experience">Ajax and the User Experience</a></h1><time class="post__published">November 12, 2009</time></header><div class="post__content"><p>The code running this website is well over a year old now and, as I&#39;ve gone back to upgrade/fix things, I&#39;ve noticed that it is clunky and highly inflexible. The implementation I&#39;ve used is actually very, very similar to what I used in YPNgine back in 2003; a switch statement calling functions from an included script based upon variables passed in the query string. Granted, there&#39;s going to be some degree of that in any implementation, but through some tinkering with the music page and interviewing with some of the developer&#39;s at Digg has led me to a new paradigm: a set RESTful API calls independent of all front end management.</p>
<p>Now, aside from the nice code separation and simplification of feature adds and maintainability this provides, it also opens up a new world to Ajax. Since all the data is accessible via query string, almost all the usual functionality that would normally call for separate pages can be added in without ever having to leave the landing page. In fact, I&#39;ve <a href="http://dxprog.dyndns.org/dxsite2">implemented this</a> functionality on the test server. As interesting as this may sound, it raises some interesting issues concerning usability and the user experience.</p>
<p>The largest concern is that of site navigation or, more specifically, navigation history. In a normal site, every page you visit will be added to the site history, appending itself to the not only pages visited, but the forward and back buttons as needed. With Ajax, you have none of this. Were you to click a link to a story and have it loaded via Ajax, your browser history does not change. Pressing the back button will take you to the previous entered URL and not the previous page because, technically, you&#39;re still on the same page. The new page won&#39;t be placed in browsing history which could make finding back a particular story particularly difficult. And, finally, because the page never changes, neither does the URL in the address bar which could lead to confusion.</p>
<p>Say you entered my site on the gallery page using the url <a href="http://dxprog.com/gallery">http://dxprog.com/gallery</a> and eventually found your way to to the June 2006 blog archives, specifically to a story about my <a href="http://dxprog.com/entry/tryin-to-survive/">life without a laptop</a>. Because the page never actually changes, the address bar will continue to read <a href="http://dxprog.com/gallery">http://dxprog.com/gallery</a> even though that content is no longer there. This would have made my retrieval of the URL for that story more difficult and, had the title not been permalinked, I wouldn&#39;t have been able to retrieve it at all.</p>
<p>Another thing to take into consideration is search engines. When Google crawls your site it doesn&#39;t have JavaScript enabled. So, unless you write duplicate functionality to generate the page before sending to the browser, none of your content will get indexed. I face this problem with the current gallery implementation; even though there is a way for me to access individual items via the query string, there are no hard links on the gallery page itself to point to them. Even if there was, all of the content is loaded on the client side so search engine spiders are just going to get a blank page devoid of content. Not a very smart idea if you want that content indexed.</p>
<p>In conclusion, when it comes to Ajax and dynamically loading content, you really have to consider carefully what should and shouldn&#39;t be dynamically loaded. Portal pages - any page with links into sub pages of the site such - are probably best left to the traditional method of loading a new page for each item. Smaller things such as paginating an entry&#39;s comments probably wouldn&#39;t hurt as much since it is an aside to the main material. Though, even then there may be something interesting you&#39;d want picked up on a search engine. It&#39;s really is a balancing act between slick functionality and overall usability.</p>
</div></article><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/id3lib-a-tag-library-for-all-seasons">ID3Lib - A tag library for all seasons</a></h1><time class="post__published">October 21, 2009</time></header><div class="post__content">![](http://images.dxprog.com/blog/id3lib.png "image")

ID3Lib [ [Download](http://dxprog.com/files/ID3Lib.zip) ]

As one may have derived from previous posts, I have a [project](http://labs.dxprog.com/smp/) the uses MP3s quite heavily. As such, retrieving tag data from these is quite an important thing. Having recently migrated my personal server to Windows, I needed a non-Linux variant of my previous [tag read](http://dxprog.com/entry/building-a-web-based-media-player---part-1/). I thought that while I was at it I could add an additional feature, namely saving embedded album art. Unfortunately, I was unable to find any clear directions on how to do so using [TagLib](http://developer.kde.org/~wheeler/taglib.html), so I created my own library. Three different times. In three different languages. A C++ version, a .NET version and, finally, a PHP version.[break]

Each of these libraries works pretty similar, but to give you the general idea, I'll write out a simple program for each.

```c++
#include <iostream>
#include "id3lib.h"

using namespace std;

void main () {
	ID3Lib id3("my.mp3"); // Create the object
	if (!id3)
		cout << "Unable to parse file";
	else {
		cout << "Title: " << id3.artist() << "n"; // Output title using shortcut method
		cout << "Album: " << id3.tag("TALB") << "n"; // Can retrieve any tag with this method
		id3.saveAlbumArt ("album_art.jpg"); // Save any embedded picture
	}
}
```

[code=c#]using System;
using System.Collections.Generic;
using System.Text;
using Id3Lib_Net;

namespace Id3LibNet_Test
{
    class Program
    {
        static void Main(string[] args)
        {
            Reader t = new Reader("my.mp3"); // Load the MP3 file
            Console.WriteLine(t.title()); // Print out the title using shorthand method
			Frame album = t.getFrame("TALB"); // All loaded tags can be retrieved this way
			t.savePicture ("album_art.jpg");
        }
    }
}[/code]

```php
include ("id3lib.php");

$id3 = new ID3Lib ("my.mp3"); // Create the ID3Lib object
if (!$id3->getErr()) { // Will be null if load was successful
	echo ("Title: ".$id3->title); // A shortcut for getting the title
	echo ("Album: ".$id3->tags->TALB); // All tags can be accessed this way
	$id3->savePicture ("album_art.jpg"); // Saves an embedded picture
}
else
	echo ("There was an error opening the MP3: ".$id3->getErr());
```

Each library includes a set of methods/properties for the following common tags: title, album, artist, disc, track, year.

All three libraries are licensed under the GPLv3 and have the original source code, so you can do with them what you wish, though credit and a link back here is always nice :-).

ID3Lib [ [Download](http://dxprog.com/files/ID3Lib.zip) ]

Disclaimer: I have only tested these on MP3s I have available to me, so it's very possible that you may have issues with this library. If you do, please leave a comment and I'll update the libs accordingly.</div></article><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/id3lib-a-tag-library-for-all-seasons">ID3Lib - A tag library for all seasons</a></h1><time class="post__published">October 21, 2009</time></header><div class="post__content"><p><img src="http://images.dxprog.com/blog/id3lib.png" alt="" title="image"></p>
<p>ID3Lib [ <a href="http://dxprog.com/files/ID3Lib.zip">Download</a> ]</p>
<p>As one may have derived from previous posts, I have a <a href="http://labs.dxprog.com/smp/">project</a> the uses MP3s quite heavily. As such, retrieving tag data from these is quite an important thing. Having recently migrated my personal server to Windows, I needed a non-Linux variant of my previous <a href="http://dxprog.com/entry/building-a-web-based-media-player---part-1/">tag read</a>. I thought that while I was at it I could add an additional feature, namely saving embedded album art. Unfortunately, I was unable to find any clear directions on how to do so using <a href="http://developer.kde.org/~wheeler/taglib.html">TagLib</a>, so I created my own library. Three different times. In three different languages. A C++ version, a .NET version and, finally, a PHP version.[break]</p>
<p>Each of these libraries works pretty similar, but to give you the general idea, I&#39;ll write out a simple program for each.</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &quot;id3lib.h&quot;

using namespace std;

void main () {
    ID3Lib id3(&quot;my.mp3&quot;); // Create the object
    if (!id3)
        cout &lt;&lt; &quot;Unable to parse file&quot;;
    else {
        cout &lt;&lt; &quot;Title: &quot; &lt;&lt; id3.artist() &lt;&lt; &quot;n&quot;; // Output title using shortcut method
        cout &lt;&lt; &quot;Album: &quot; &lt;&lt; id3.tag(&quot;TALB&quot;) &lt;&lt; &quot;n&quot;; // Can retrieve any tag with this method
        id3.saveAlbumArt (&quot;album_art.jpg&quot;); // Save any embedded picture
    }
}
</code></pre>
<p>[code=c#]using System;
using System.Collections.Generic;
using System.Text;
using Id3Lib_Net;</p>
<p>namespace Id3LibNet_Test
{
    class Program
    {
        static void Main(string[] args)
        {
            Reader t = new Reader(&quot;my.mp3&quot;); // Load the MP3 file
            Console.WriteLine(t.title()); // Print out the title using shorthand method
            Frame album = t.getFrame(&quot;TALB&quot;); // All loaded tags can be retrieved this way
            t.savePicture (&quot;album_art.jpg&quot;);
        }
    }
}[/code]</p>
<pre><code class="lang-php">include (&quot;id3lib.php&quot;);

$id3 = new ID3Lib (&quot;my.mp3&quot;); // Create the ID3Lib object
if (!$id3-&gt;getErr()) { // Will be null if load was successful
    echo (&quot;Title: &quot;.$id3-&gt;title); // A shortcut for getting the title
    echo (&quot;Album: &quot;.$id3-&gt;tags-&gt;TALB); // All tags can be accessed this way
    $id3-&gt;savePicture (&quot;album_art.jpg&quot;); // Saves an embedded picture
}
else
    echo (&quot;There was an error opening the MP3: &quot;.$id3-&gt;getErr());
</code></pre>
<p>Each library includes a set of methods/properties for the following common tags: title, album, artist, disc, track, year.</p>
<p>All three libraries are licensed under the GPLv3 and have the original source code, so you can do with them what you wish, though credit and a link back here is always nice :-).</p>
<p>ID3Lib [ <a href="http://dxprog.com/files/ID3Lib.zip">Download</a> ]</p>
<p>Disclaimer: I have only tested these on MP3s I have available to me, so it&#39;s very possible that you may have issues with this library. If you do, please leave a comment and I&#39;ll update the libs accordingly.</p>
</div></article><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/getting-a-youtube-flv-through-php">Getting a YouTube FLV through PHP</a></h1><time class="post__published">October 4, 2009</time></header><div class="post__content">![](http://images.dxprog.com/blog/php_corner.png "PHP Corner")
Recently, while making some additions to the [Music Page](http://labs.dxprog.com/smp/), I came across the need to get the location of a YouTube FLV. Unfortunately, most of my googling turned up outdated results that no longer work. Fortunately, unlike a certain [other](http://hulu.com/) site, it's not impossible. Below is a quick explanation of what I got to work. I'll be assuming that you know how to get your hands on the video ID (the "v" parameter in the query string).[break]

There really is only one thing that's needed by YouTube to get the video file, and that's the video token. As far as I can tell, this is a time sensitive key that is generated for the user to prevent abuse on the YouTube servers. Luckily, this is pretty easy to obtain. The get_video_info page returns not only the token, but all sorts of other valuable information about the video, such as author, date uploaded, length in seconds, etc. Here's a small function that retrieves this information and returns it as an object:

[code=php]function ytGetInfo ($id)
{
	$file = file_get_contents ("http://www.youtube.com/get_video_info?&video_id=$id");
	$a = explode ("&", urldecode ($file));
	foreach ($a as $i) {
		$e = explode ("=", $i, 2);
		$ret->$e[0] = $e[1];
	}
	return $ret;
}[/code]

Simple stuff, really. The contents of get_video_info are retrieved and stored in $file. This information comes URL encoded, so we first need to decode that. As with any URL string, each variable is separated by an ampersand (&), so when calling [explode](http://us.php.net/manual/en/function.explode.php). That returns the variable/value pairs in an array ([0]=>"author=dxprog", [1]=>"token=asi940tnas", ...). Iterating through each of those, we then explode the var/value pairs and add them to our outgoing object. Now we have the token (amongst other info), so next will be retrieving the video file itself.

YouTube uses get_video to return where the actual video is stored. Now, I don't know all the nuances of this method, but as of this writing, it returns a 303 See other HTTP response code with the location header pointing to the actual, real address of the video file. We'll functionize that:

```php
function ytGetVideoPath ($id)
{
	$info = ytGetInfo ($id);
	$token = $info->token;
	$headers = get_headers ("http://www.youtube.com/get_video?video_id=$id&t=$token&fmt=18");
	foreach ($headers as $item) {
		if (strpos ($item, "Location: ") !== false) {
			return str_replace ("Location: ", "", $item);
		}
	}
	return false;
}
```

First thing this function does is grab the video information so that we can get the token. We then retrieve the headers of the video providing the video ID _(v)_ and the token _(t)_ as parameters to get_video. The _fmt_ parameter specifies the quality video you want, none being low, 18 being high, and 22 being HD. Using the [get_headers](http://us.php.net/manual/en/function.get-headers.php) function, we should be returned a 303 response code with the location header set to the video location. I can't guarantee that this is always the case, but it hasn't failed me yet.

From here, you can do with the returned URL as you please. You can use [file_get_contents](http://us.php.net/manual/en/function.file-get-contents.php) or [fsockopen](http://us.php.net/manual/en/function.fsockopen.php) - my favorite - to download the stream, load it into your flash video player or whatever you want. I hope you found this little guide useful. If you run into any problems with the above code, please leave a comment below and I'd be happy to help. Cheers!</div></article><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/getting-a-youtube-flv-through-php">Getting a YouTube FLV through PHP</a></h1><time class="post__published">October 4, 2009</time></header><div class="post__content"><p><img src="http://images.dxprog.com/blog/php_corner.png" alt="" title="PHP Corner">
Recently, while making some additions to the <a href="http://labs.dxprog.com/smp/">Music Page</a>, I came across the need to get the location of a YouTube FLV. Unfortunately, most of my googling turned up outdated results that no longer work. Fortunately, unlike a certain <a href="http://hulu.com/">other</a> site, it&#39;s not impossible. Below is a quick explanation of what I got to work. I&#39;ll be assuming that you know how to get your hands on the video ID (the &quot;v&quot; parameter in the query string).[break]</p>
<p>There really is only one thing that&#39;s needed by YouTube to get the video file, and that&#39;s the video token. As far as I can tell, this is a time sensitive key that is generated for the user to prevent abuse on the YouTube servers. Luckily, this is pretty easy to obtain. The get_video_info page returns not only the token, but all sorts of other valuable information about the video, such as author, date uploaded, length in seconds, etc. Here&#39;s a small function that retrieves this information and returns it as an object:</p>
<p>[code=php]function ytGetInfo ($id)
{
    $file = file_get_contents (&quot;<a href="http://www.youtube.com/get_video_info?&amp;video_id=$id&quot;)">http://www.youtube.com/get_video_info?&amp;video_id=$id&quot;)</a>;
    $a = explode (&quot;&amp;&quot;, urldecode ($file));
    foreach ($a as $i) {
        $e = explode (&quot;=&quot;, $i, 2);
        $ret-&gt;$e[0] = $e[1];
    }
    return $ret;
}[/code]</p>
<p>Simple stuff, really. The contents of get_video_info are retrieved and stored in $file. This information comes URL encoded, so we first need to decode that. As with any URL string, each variable is separated by an ampersand (&amp;), so when calling <a href="http://us.php.net/manual/en/function.explode.php">explode</a>. That returns the variable/value pairs in an array ([0]=&gt;&quot;author=dxprog&quot;, [1]=&gt;&quot;token=asi940tnas&quot;, ...). Iterating through each of those, we then explode the var/value pairs and add them to our outgoing object. Now we have the token (amongst other info), so next will be retrieving the video file itself.</p>
<p>YouTube uses get_video to return where the actual video is stored. Now, I don&#39;t know all the nuances of this method, but as of this writing, it returns a 303 See other HTTP response code with the location header pointing to the actual, real address of the video file. We&#39;ll functionize that:</p>
<pre><code class="lang-php">function ytGetVideoPath ($id)
{
    $info = ytGetInfo ($id);
    $token = $info-&gt;token;
    $headers = get_headers (&quot;http://www.youtube.com/get_video?video_id=$id&amp;t=$token&amp;fmt=18&quot;);
    foreach ($headers as $item) {
        if (strpos ($item, &quot;Location: &quot;) !== false) {
            return str_replace (&quot;Location: &quot;, &quot;&quot;, $item);
        }
    }
    return false;
}
</code></pre>
<p>First thing this function does is grab the video information so that we can get the token. We then retrieve the headers of the video providing the video ID <em>(v)</em> and the token <em>(t)</em> as parameters to get_video. The <em>fmt</em> parameter specifies the quality video you want, none being low, 18 being high, and 22 being HD. Using the <a href="http://us.php.net/manual/en/function.get-headers.php">get_headers</a> function, we should be returned a 303 response code with the location header set to the video location. I can&#39;t guarantee that this is always the case, but it hasn&#39;t failed me yet.</p>
<p>From here, you can do with the returned URL as you please. You can use <a href="http://us.php.net/manual/en/function.file-get-contents.php">file_get_contents</a> or <a href="http://us.php.net/manual/en/function.fsockopen.php">fsockopen</a> - my favorite - to download the stream, load it into your flash video player or whatever you want. I hope you found this little guide useful. If you run into any problems with the above code, please leave a comment below and I&#39;d be happy to help. Cheers!</p>
</div></article><div class="paging"><a href="http://dev.dxprog.com/dxprog.github.io/docs/archives/130.html" class="paging__link paging__link--next">Earlier Posts</a><a href="http://dev.dxprog.com/dxprog.github.io/docs/archives/128.html" class="paging__link paging__link--previous">Later Posts</a></div></section><footer class="footer"><p class="footer__copyright">Copyright © 2018 Matt Hackmann</p></footer></section></body></html>