<!DOCTYPE html>
<html><head><title>Archives - Page 12</title><link rel="stylesheet" type="text/css" href="static/css/index.css"/></head><body><section class="article-list"><article><h2>A Thought</h2><time>November 13, 2015</time><div><p>I don&#39;t like talking about things in the political or socio-economic realm. I abhor it, even. A couple reasons, A) I&#39;m bad at it, B) it requires an emotional component that I don&#39;t have enough of. That said, I&#39;m going to make a societal rant.</p>
<p>I of course am going to be speaking of the recent unpleasantness going down in France. I&#39;ve been quasi-monitoring various threads on reddit and - unsurprisingly - it would seem the collective world&#39;s head is turned to look at Islam (or, rather, Muslims) as being the cause. Now, I wouldn&#39;t be surprised if extremists who claim to be working in the name of this religion are involved, but that&#39;s not why I&#39;m here. Well, I suppose it is. A lot of the sentiment seems to be around the notion that this particular religion is <em>making</em> people do this.</p>
<p>No. No it&#39;s not. And the people who claim this are themselves probably hypocrites.</p>
<p>I had an interesting thought as I was grabbing a piece of cheese from the fridge. It&#39;s the exact same argument as &quot;video games make those who play them violent&quot;. I&#39;ve written about this before, maybe here, maybe for school, but the answer is: no, of course they don&#39;t. A video game, movie, book, or piece of music doesn&#39;t make you violent. If you&#39;re acting out on things, you were probably pre-disposed to such things already. The <em>exact same idea</em> applies to this notion that a religion will turn somebody violent.</p>
<p>These individuals <em>chose</em> to kill of their own free will. We as humans kind of have that privilege.</p>
<p>In the end it&#39;s not video games and it&#39;s not religion causing people to cause fucked up mayhem against innocent lives. It&#39;s extremely disturbed individuals who will find any reason to validate the horrendous crimes they already want to commit. Intangible concepts don&#39;t cause people to kill.</p>
<p>People do that all by themselves.</p>
<p>And it goes without saying that they are acting and representing themselves and themselves only, not the whole. They may represent a subset of people, but simply by being human, they actually represent all people.</p>
<p>So, if you subscribe to the group mindset, does that not make all of us murderers?</p>
</div></article><article><h2>Idiocy, Caching, and Reducing Round Trips</h2><time>July 7, 2015</time><div><p>Over the last few days, I&#39;d been receiving high CPU usage alerts from my host. A tad perplexed, I&#39;d login in, check the graph and logs to see that, indeed, CPU usage was high, but nothing really seemed out of the ordinary. Google Analytics showed that traffic was moderately high, to be expected with a few widely visible brackets going on in /r/anime, but it wasn&#39;t anything to raise an eyebrow at. Still, you can&#39;t look at the following graph and notice a very predictable period of high activity:</p>
<p><img src="http://i.imgur.com/0IUrapB.png" alt="" title="Those peaks would be terrible to bike up"></p>
<p>These peaks were actually coinciding with the most prominent bracket updating, bringing with it a fresh wave users every day. By the time I had received the third CPU alert email, I knew something was up and decided to actually take a look. Luckily, I didn&#39;t have to look far. The MySQL query graph was showing 1000+ read queries per second, certainly out of ordinary given how aggressive I am about caching.</p>
<p>Suspecting that something might be awry with memcache, but not actually wanting to bounce it, I bugged the cache library with some <a href="https://github.com/dxprog/anime-bracket/commit/9e96a5838d06e0d3fc034cbc08653ab3329c8c5f">stats tracking</a> hoping that it would turn up something I had overlooked. Indeed, I know where things are cached, but have never really had a list of just how all of this looks in production. And, true to that, I found something that I had not anticipated: every call to Dal::getById - a method on a class that database models extend - was a cache miss. Every. Single. One. And there were thousands of these, which very quickly explained the high query volume. All of this I found out in about 30 seconds of having that profiling code live, which is good because it also brought the site down and I had to disable it...</p>
<p>With that information, I had a pretty solid lead as to where I needed to be checking for issues: the aforementioned getById method. I was a bit baffled because I knew there should be caching on that, it&#39;s one of the two reasons that the method even exists (the other reason being for coding simplicity). So I get in there and take a look. Lo and behold, the cache is checked but <a href="https://github.com/dxprog/anime-bracket/commit/5455f8bc589e4f924714463857c8b8cf64eecb37">nothing was ever actually stored back</a>. Of course, I had to fuck the fix up once before <a href="https://github.com/dxprog/anime-bracket/commit/46618c77c0cf58a9f8555f05f86a413817bb3069">actually resolving it</a>.</p>
<p>Once that was shoved to production, I was greeted with this wonderful little sight:</p>
<p><img src="http://i.snag.gy/bGki8.jpg" alt="" title="Down.. down.. down.. ROCK LOBSTER"></p>
<p>So, the immediate issue was fixed, but there was still something obviously very wrong if I was individually getting so many singular items by ID. As it turns out, in one of the most looped pieces of code in the entire project, I was making not one but <em>two</em> calls to get an item by ID. The whole output was cache guarded, but on a per user basis. In the case of the popular running bracket, that&#39;s over 400 queries per user per page generation. Unacceptable.</p>
<p>So, in one of those cases of code brevity != code speed, <a href="https://github.com/dxprog/anime-bracket/commit/dd6a4251c94ca47454abd6a004c2d64c952664da">I did a heavy refactor to stash all the IDs that needed to be fetched and then make a big batch call later</a>. There are some trade-offs here. There&#39;s still room for optimization here, especially if the getById calls are aggressively cached (indeed, the data fetched changes rarely). Or, the data returned from the batched call could be cached in shorter intervals. It still needs to be looped through as it&#39;s decorated with user specific data, but that would bring the overhead down to one big-ish hit only every few minutes. Still, with those measures currently in place, the CPU load issue has gone away and the queries per second is generally down in the double digits on average.</p>
<p>The true sign that everything is working, though, was the lack of an email in my inbox this afternoon.</p>
</div></article></section></body></html>