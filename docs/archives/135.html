<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Archives - Page 135</title><link rel="stylesheet" type="text/css" href="http://dev.dxprog.com/dxprog.github.io/docs/static/css/index.css"/></head><body><section class="rollup-page"><section class="intro-bar"><img src="http://dev.dxprog.com/dxprog.github.io/docs/static/images/me.jpg" alt="Matt Hackmann" class="intro-bar__photo"/><h1 class="intro-bar__header"><span class="intro-bar__name intro-bar__name--first">Matt</span><span class="intro-bar__name intro-bar__name--last">Hackmann</span></h1><h2 class="intro-bar__subhead">The thoughts and goings-on of some programmer dude.</h2><nav class="intro-bar__social-nav"><ul class="social-links"><li class="social-links__item"><a class="social-links__link social-links__link--rss" target="_blank" href="http://feeds.feedburner.com/dxprog">RSS Feed</a></li><li class="social-links__item"><a class="social-links__link social-links__link--github" target="_blank" href="https://github.com/dxprog">GitHub</a></li><li class="social-links__item"><a class="social-links__link social-links__link--twitter" target="_blank" href="https://twitter.com/dxprog">Twitter</a></li><li class="social-links__item"><a class="social-links__link social-links__link--linkedin" target="_blank" href="https://www.linkedin.com/in/mhackmann">LinkedIn Profile</a></li></ul></nav></section><section class="article-list"><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/the-de-evolution-of-nintendo-box-asses">The De-evolution of Nintendo Box Asses</a></h1><time class="post__published">October 19, 2008</time></header><div class="post__content"><p>It can be argued that Nintendo has somewhat ripped off Apple when it comes to design and asthetics. Everything is very simple and clean almost to the point of being sterile (as in the hospital, not the inability to bear children). However, one disturbing trend seems to be their boxes. Not the fronts, mind you, but rather the backs. Join me as I go through a box design from every generation of Nintendo console (save N64) and grade them on design.[break]</p>
<p>Legend of Zelda (NES)
<img src="http://www.dxprog.com/pics/zelda_box.jpg" alt="" title="image"></p>
<p>Now, being of thick German heritage I&#39;m going to allow the Nazi in me to speak for a second. The first two sentences in that first paragraph should be rolled together with a comma seperating them, not two sentences. But enough about that, more about the design. They&#39;ve used their space wisely on this one. There&#39;s plenty of informative text on the left and some snazzy screenshots of Link kicking ass on the right. The text placement on the left bugs me a little, especially with that strategy guide picture throwing off the alignment of the text to the right. I also think they could&#39;ve used a font that wasn&#39;t so narrow as it makes things seem a little crowded. The UPC and logos on the bottom are nonintrusive to the other elements on the box. The logo (or lack thereof) kind of bothers me, but being the first game in the franchise I&#39;ll go easy. On the whole, this box conveys its message in a manner that&#39;s pretty easy to read and for that I give Legend of Zelda a B.</p>
<p>Star Fox (SNES)
<img src="http://www.dxprog.com/pics/starfox_box.jpg" alt="" title="image"></p>
<p>In my opinion, the best design of all the box arts I will review. The logo up in the corner is super kick ass and plays off the title nicely. The text directly below is rediculously crisp and easy to read and the changup in color is a nice way to guide your eye to where they want. The pictures of the Fox team are well placed (and pretty awesome, too) and fit the theme pretty nicely. Of curse, there are the screenshots balancing out the upper left and advertising the 3D amazingness of the Super FX chip whose logo is below. The logos at the bottom are still pretty reserved, though they kind of do creep up into the main part of the box. I also think the Super FX logo should have been down there or placed closer to the block of text advertising it. However, this is an awesome box design, easy to read and kick ass looking to boot. I give Star Fox an A.</p>
<p>Paper Mario: Thousand Year Door (GCN)
<img src="http://www.dxprog.com/pics/mariorpg_box.jpg" alt="" title="image"></p>
<p>Here&#39;s where things begin to go south. First of all, the &quot;requirements&quot; is throwing off the flow of design. It is far too tall for being up at the top. I understand the utilitarian-ness of it, but taking up that much room? How about you move it down to the bottom and once you&#39;ve sold the game and person wants to know this, then they&#39;ll see it. The main text on this, whilst not illegible, is very close to bordering on it. The color is very similiar to that of the background (hence the white border), but their choice of font wasn&#39;t helping either. You should rarely or never use a stylistic font such as this for blocks of text. It works well for the &quot;What Sleeps Behind the Door?&quot; banner, but not very well for everything else especially when they get the text really small underneath the screenshots. And while we&#39;re talking about the screen shots, these are actually okay for the most part, at least the ones on the bottom. Then there&#39;s the random screenshot up at the top right that was probably thrown in as a space filler because of the crap that sits to its left. The Mario characters filling in the vertical gaps between the top and the screenshots is decent, though their placement seems slightly uninspired. And, what&#39;s the the random confetti bits? There&#39;s so few of them that it seems out of place. Finally, the logos and stuff at the bottom are now taking up a third of the entire box. Why the hell do you need to shove down my throat so much that playing your game will give me seizures? Not only do you tell me on this box, but you also include a booklet about it and the first screen of the game tells me! My final verdict on this one is a C, kind of nice looking but bordering on difficult to read.</p>
<p>Super Smash Bros. Brawl
<img src="http://www.dxprog.com/pics/brawl_box.jpg" alt="" title="image">
And, here we are. The uber clean Wii generation. Oh? What&#39;s this? This box looks more like the back of a Microsoft product instead of the cleanly designed crap from Cupertino. I really don&#39;t even know where to begin on this one. I suppose I&#39;ll start by saying all the text is microscopic and it&#39;s even worse if you are a border jumper and have to read the ranslations. Which makes me ask: why so many damned translations? Last I knew America was a predominately English spaking country and I&#39;m pretty sure this game is also in English. And, dear God, why is all the text in comic sans? It would be hard enough to read in a nice, clean sans-serif font, but this is unacceptable. With all that extra text they&#39;ve had to stick in crappy ass &quot;screenshots&quot; and I put that in quotes because most of them look like freeze frames from the first E3 trailer. There are two real screenshots: the one at the top and the teeny, tiny one in the online play box. All this stuff seems to just have been vomitted on the canvas with very little rhyme or reason and it&#39;s extremely difficult to read. And, finally, the part that pisses me off the most. If you&#39;d paid attention to the last three boxes you&#39;d have noticed that there was an alarming trend where the logos, barcodes, warnings, etc. gradually took up more of the box. Well, on Smash Bros Brawl they went whole hog and now it occupies HALF THE FUCKING BOX! With all those red warning labels, I feel more like I&#39;m reading the back of a bottle of cyanide pills than a game box. And, of course, it&#39;s in fifty thousand different languages. WHAT THE FUCK?! I WANT TO GET SEIZURES, POR FAVOR! How about you throw in a robot that tells you that you&#39;ll get seizures whilst raping your ass with a spiked dildo?! You&#39;re already raping our eyes, how can it get worse?! The only real good thing that can be said about this one is that the possible controllers seems more out of the way, but it&#39;s of little use as they cram more stuff in than a drunk Paris Hilton. My final rating: F</p>
<p>Well, Nintendo, you keep on making all your stuff seem &quot;clean&quot; and &quot;inviting&quot;. We all know the truth and that truth is hiding on the back of each and every game box that is sitting on store shelves with your name on it.</p>
</div></article><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/ive-been-killed">I&#x27;ve been killed!</a></h1><time class="post__published">September 2, 2008</time></header><div class="post__content"><p>[url=<a href="http://squareheaded.smackjeeves.com/comics/429172/sigh-here-we-go-again/]![]">http://squareheaded.smackjeeves.com/comics/429172/sigh-here-we-go-again/]![]</a>(<a href="http://www.dxprog.com/pics/bumpers/square_headed.png">http://www.dxprog.com/pics/bumpers/square_headed.png</a> &quot;image&quot;)[/url]</p>
<p>This is how I want to die. To be murdered by my favorite villain from my favorite game would totally make my day... as long as I&#39;m already old or something. Be sure to check out <a href="http://squareheaded.smackjeeves.com/comics/">Square Headed</a>. It updates on Thursdays, but is currently updated three days a week while in story arc mode.</p>
<p>On an interesting note, my last name is actually supposed to be pronouced &quot;Hawk-mann&quot;.</p>
</div></article><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/ive-been-killed">I&#x27;ve been killed!</a></h1><time class="post__published">September 2, 2008</time></header><div class="post__content">[url=http://squareheaded.smackjeeves.com/comics/429172/sigh-here-we-go-again/]![](http://www.dxprog.com/pics/bumpers/square_headed.png "image")[/url]

This is how I want to die. To be murdered by my favorite villain from my favorite game would totally make my day... as long as I'm already old or something. Be sure to check out [Square Headed](http://squareheaded.smackjeeves.com/comics/). It updates on Thursdays, but is currently updated three days a week while in story arc mode.

On an interesting note, my last name is actually supposed to be pronouced "Hawk-mann".</div></article><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/building-a-web-based-media-player---part-1">Building a Web-based Media Player - Part 1</a></h1><time class="post__published">August 31, 2008</time></header><div class="post__content"><p>For the past month I&#39;ve been tinkering with Flex and my little Linux server. One of the projects that grew out of this was a web media player with which I could listen to all my tunes wherever there happened to be some scraps of internet. This has been one of the coolest projects I&#39;ve worked on in some time. It successfully blends nearly all of my programming skills: PHP/MySQL, Javascript, XML, Flex/Actionscript 3.0, and some C++. I&#39;m going to write a series of tutorials walking through what I&#39;ve done in hopes of bringing this coolness to the masses. I&#39;m going to be fairly verbose covering subjects that any seasoned programmer can pretty much skip over. In the first installment I&#39;m going to cover creating the database and getting song information from the MP3s.[break]</p>
<p>The first thing to do, obviously, is set up the database tables. I&#39;ve kept my setup fairly minimalistic having tables for artists, albums, and tracks. I plan to expand later to track playback habits and so forth, but these are all you need to make your player fully functional. I&#39;ve got my tables setup as follows:
<strong>artists</strong>
[list][item]id (int 4, primary key)[/item][item]name (varchar 100)[/item][/list]
<strong>albums</strong>
[list][item]id (int 4, primary key)[item][item]title (varchar 100)[/item][item]artist (int 3)[/item][/list]
<strong>tracks</strong>
[list][item]id (int 11, primary key)[/item][item]title (varchar 100)[/item][item]artist (int 4)[/item][item]album (int 4)[/item][item]track_num (int 3)[/item][item]play_count (int 5)[/item][item]date_played (int 11)[/item][/list]
Most of these fields should be self-explanitory. The tracks table can expand or contract to include what ever metadata you want (I personally left out genre as I hardly ever use that). date_played will store the Unix timestamp of the last time the song was played. I personally like storing my timestamps without formatting as to forego the unnecessary strtotime () conversion. We&#39;ll use this later when we create the recently played list.</p>
<p>About now I would begin to discuss how we&#39;re going to get this information into the database, but first we need to be able to get the information from the files. I&#39;ve got two methods for this and it all really depends on your programming skills and what you have available on your server. The first, and most available option is through Actionscript. Let&#39;s jump to code.</p>
<pre><code class="lang-actionscript">var tagLoader:Sound = new Sound();
tagLoader.load (&quot;my_song.mp3&quot;);
tagLoader.addEventListener (Event.ID3, tagsLoadedHandler)
tagLoader.addEventListener (Event.COMPLETE, tagsLoadedHandler)

function tagsLoadedHandler (e:Event):void
{
    var title:String = tagLoader.id3.title;
    var artist:String = tagLoader.id3.artist;
    var album:String = tagLoader.id3.album;
    var track:String = tagLoader.id3.track;
    // Send to database
    tagLoader.removeEventListener (Event.COMPLETE, tagsLoadedHandler);
}
</code></pre>
<p>[b]<em>Lines 1-2</em>[/b]
Nothing terribly exciting. We set up our Sound object which will be loading the MP3 and getting ID3 information. Immediately after we load the MP3 file _my_song.mp3_ into our Sound object.
[b]<em>Lines 3-4</em>[/b]
We set up two event listeners so we can catch the data. The first fires once ID3 information has been retrieved. Depending on your MP3 file, this event won&#39;t always fire so we set up the COMPLETE event so that the code is run regardless. We&#39;ll be talking more about that in the next tutorial.
[b]<em>Lines 8-12</em>[/b]
We store the song information for temporary storage until we send it all off to the database (covered in the next tutorial).
[b]<em>Line 13</em>[/b]
We remove the event listener on the COMPLETE event. In the probable case that the ID3 event was dispatched we want the COMPLETE event removed otherwise all this code will run again adding your song to the database twice. We don&#39;t want to pull and iTunes with duplicate song issues.</p>
<p>Alright, that&#39;s the first, and slowest way to do things. I say slowest because it actually requires that the song be downloaded to your computer before it gets the information. This isn&#39;t bad if you&#39;re on a LAN connection, but it&#39;s not near as fast as using the server itself to get the information (which we&#39;ll be doing now).
[code=c++]#include &lt;taglib/tag.h&gt;</p>
<p>#include &lt;taglib/fileref.h&gt;</p>
<p>using namespace std;</p>
<p>void readID3 (char *fileName)
{</p>
<pre><code>TagLib::FileRef f(fileName);

cout &lt;&lt; &quot;\\t\\t&lt;album&gt;&quot; &lt;&lt; f.tag()-&gt;album() &lt;&lt; &quot;&lt;/album&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;artist&gt;&quot; &lt;&lt; f.tag()-&gt;artist() &lt;&lt; &quot;&lt;/artist&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;title&gt;&quot; &lt;&lt; f.tag()-&gt;title() &lt;&lt; &quot;&lt;/title&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;genre&gt;&quot; &lt;&lt; f.tag()-&gt;genre() &lt;&lt; &quot;&lt;/genre&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;year&gt;&quot; &lt;&lt; f.tag()-&gt;year() &lt;&lt; &quot;&lt;/year&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;track&gt;&quot; &lt;&lt; f.tag()-&gt;track() &lt;&lt; &quot;&lt;/track&gt;\\n&quot;;
</code></pre><p>}</p>
<p>int main (int argc, char *argv[])
{</p>
<pre><code>if (argc == 1) {
    printf (&quot;Usage --\\ntid3xml INPUT\\n&quot;);
    return 1;
}

cout &lt;&lt; &quot;&lt;?xml version=&quot;1.0&quot; ?&gt;\\n&quot;;
cout &lt;&lt; &quot;&lt;songs&gt;\\n&quot;;

for (int i = 1; i &lt; argc; i++) {
    cout &lt;&lt; &quot;\\t&lt;song file=\\&quot;&quot; &lt;&lt; argv[i] &lt;&lt; &quot;\\&quot;&gt;\\n&quot;;
    readID3 (argv[i]);
    cout &lt;&lt; &quot;\\t&lt;/song&gt;\\n&quot;;
}

cout &lt;&lt; &quot;&lt;/songs&gt;\\n&quot;;
return 0;
</code></pre><p>}[/code]
We&#39;ll be writing a small C++ program that reads ID3 information out of the MP3 file and returns XML as the output. Of course, writing the code to read ID3 tags by oneself requires some time, patience, and wading through a lot of documentation. Luckily, there are several libraries out there that will serve our purposes quite nicely. The one I have chosen is TagLib. If you&#39;re running debian getting tag lib is as simple as running:
<em>sudo apt-get install taglib-dev</em>
Now for some code:</p>
<p>I&#39;m going to skip all the includes and jump right into the meat.
[b]<em>Line 10-17</em>[/b]
This creates our TagLib object and parses the ID3 information for the file supplied to the function. This information is the output to the console.
[b]<em>Lines 25-28</em>[/b]
Checks to make sure a file was passed. If not it outputs a friendly usage guide and moves on. In actuality, since this will be later parsed by a PHP script, it would probably be a better idea to output an error code encapsulated in XML tags.
[b]<em>Lines 30-31</em>[/b]
Set up the XML file structure.
[b]<em>Lines 33-37</em>[/b]
Loop through every file passed and outputs the ID3 information for each.
[b]<em>Lines 39-40</em>[/b]
Close up and quit.
This script has a lot of obvious advantages. First of all is speed. Since it&#39;s being run on the server, where the files are kept, there is no waiting for the song to download to get the file info. Secondly, it can parse many files at one time making batch adds possible.
Well, that concludes part one of this tutorial. Next time we&#39;ll cover adding the songs to the database utilizing what was covered in this tutorial. We&#39;ll cover both scanning an existing library and a creating a front end for adding new songs. &#39;Til next time, happy coding.</p>
</div></article><article class="post"><header class="post__header"><h1 class="post__title"><a href="http://dev.dxprog.com/dxprog.github.io/docs/entry/building-a-web-based-media-player---part-1">Building a Web-based Media Player - Part 1</a></h1><time class="post__published">August 31, 2008</time></header><div class="post__content">For the past month I've been tinkering with Flex and my little Linux server. One of the projects that grew out of this was a web media player with which I could listen to all my tunes wherever there happened to be some scraps of internet. This has been one of the coolest projects I've worked on in some time. It successfully blends nearly all of my programming skills: PHP/MySQL, Javascript, XML, Flex/Actionscript 3.0, and some C++. I'm going to write a series of tutorials walking through what I've done in hopes of bringing this coolness to the masses. I'm going to be fairly verbose covering subjects that any seasoned programmer can pretty much skip over. In the first installment I'm going to cover creating the database and getting song information from the MP3s.[break]

The first thing to do, obviously, is set up the database tables. I've kept my setup fairly minimalistic having tables for artists, albums, and tracks. I plan to expand later to track playback habits and so forth, but these are all you need to make your player fully functional. I've got my tables setup as follows:
**artists**
[list][item]id (int 4, primary key)[/item][item]name (varchar 100)[/item][/list]
**albums**
[list][item]id (int 4, primary key)[item][item]title (varchar 100)[/item][item]artist (int 3)[/item][/list]
**tracks**
[list][item]id (int 11, primary key)[/item][item]title (varchar 100)[/item][item]artist (int 4)[/item][item]album (int 4)[/item][item]track_num (int 3)[/item][item]play_count (int 5)[/item][item]date_played (int 11)[/item][/list]
Most of these fields should be self-explanitory. The tracks table can expand or contract to include what ever metadata you want (I personally left out genre as I hardly ever use that). date_played will store the Unix timestamp of the last time the song was played. I personally like storing my timestamps without formatting as to forego the unnecessary strtotime () conversion. We'll use this later when we create the recently played list.

About now I would begin to discuss how we're going to get this information into the database, but first we need to be able to get the information from the files. I've got two methods for this and it all really depends on your programming skills and what you have available on your server. The first, and most available option is through Actionscript. Let's jump to code.
```actionscript
var tagLoader:Sound = new Sound();
tagLoader.load ("my_song.mp3");
tagLoader.addEventListener (Event.ID3, tagsLoadedHandler)
tagLoader.addEventListener (Event.COMPLETE, tagsLoadedHandler)

function tagsLoadedHandler (e:Event):void
{
	var title:String = tagLoader.id3.title;
	var artist:String = tagLoader.id3.artist;
	var album:String = tagLoader.id3.album;
	var track:String = tagLoader.id3.track;
	// Send to database
	tagLoader.removeEventListener (Event.COMPLETE, tagsLoadedHandler);
}
```
[b]_Lines 1-2_[/b]
Nothing terribly exciting. We set up our Sound object which will be loading the MP3 and getting ID3 information. Immediately after we load the MP3 file _my_song.mp3_ into our Sound object.
[b]_Lines 3-4_[/b]
We set up two event listeners so we can catch the data. The first fires once ID3 information has been retrieved. Depending on your MP3 file, this event won't always fire so we set up the COMPLETE event so that the code is run regardless. We'll be talking more about that in the next tutorial.
[b]_Lines 8-12_[/b]
We store the song information for temporary storage until we send it all off to the database (covered in the next tutorial).
[b]_Line 13_[/b]
We remove the event listener on the COMPLETE event. In the probable case that the ID3 event was dispatched we want the COMPLETE event removed otherwise all this code will run again adding your song to the database twice. We don't want to pull and iTunes with duplicate song issues.

Alright, that's the first, and slowest way to do things. I say slowest because it actually requires that the song be downloaded to your computer before it gets the information. This isn't bad if you're on a LAN connection, but it's not near as fast as using the server itself to get the information (which we'll be doing now).
[code=c++]#include <taglib/tag.h>
#include <taglib/fileref.h>

using namespace std;

void readID3 (char *fileName)
{

	TagLib::FileRef f(fileName);

	cout << "\\t\\t<album>" << f.tag()->album() << "</album>\\n";
	cout << "\\t\\t<artist>" << f.tag()->artist() << "</artist>\\n";
	cout << "\\t\\t<title>" << f.tag()->title() << "</title>\\n";
	cout << "\\t\\t<genre>" << f.tag()->genre() << "</genre>\\n";
	cout << "\\t\\t<year>" << f.tag()->year() << "</year>\\n";
	cout << "\\t\\t<track>" << f.tag()->track() << "</track>\\n";

}

int main (int argc, char *argv[])
{

	if (argc == 1) {
		printf ("Usage --\\ntid3xml INPUT\\n");
		return 1;
	}

	cout << "<?xml version="1.0" ?>\\n";
	cout << "<songs>\\n";

	for (int i = 1; i < argc; i++) {
		cout << "\\t<song file=\\"" << argv[i] << "\\">\\n";
		readID3 (argv[i]);
		cout << "\\t</song>\\n";
	}

	cout << "</songs>\\n";
	return 0;

}[/code]
We'll be writing a small C++ program that reads ID3 information out of the MP3 file and returns XML as the output. Of course, writing the code to read ID3 tags by oneself requires some time, patience, and wading through a lot of documentation. Luckily, there are several libraries out there that will serve our purposes quite nicely. The one I have chosen is TagLib. If you're running debian getting tag lib is as simple as running:
_sudo apt-get install taglib-dev_
Now for some code:

I'm going to skip all the includes and jump right into the meat.
[b]_Line 10-17_[/b]
This creates our TagLib object and parses the ID3 information for the file supplied to the function. This information is the output to the console.
[b]_Lines 25-28_[/b]
Checks to make sure a file was passed. If not it outputs a friendly usage guide and moves on. In actuality, since this will be later parsed by a PHP script, it would probably be a better idea to output an error code encapsulated in XML tags.
[b]_Lines 30-31_[/b]
Set up the XML file structure.
[b]_Lines 33-37_[/b]
Loop through every file passed and outputs the ID3 information for each.
[b]_Lines 39-40_[/b]
Close up and quit.
This script has a lot of obvious advantages. First of all is speed. Since it's being run on the server, where the files are kept, there is no waiting for the song to download to get the file info. Secondly, it can parse many files at one time making batch adds possible.
Well, that concludes part one of this tutorial. Next time we'll cover adding the songs to the database utilizing what was covered in this tutorial. We'll cover both scanning an existing library and a creating a front end for adding new songs. 'Til next time, happy coding.</div></article><div class="paging"><a href="http://dev.dxprog.com/dxprog.github.io/docs/archives/136.html" class="paging__link paging__link--next">Earlier Posts</a><a href="http://dev.dxprog.com/dxprog.github.io/docs/archives/134.html" class="paging__link paging__link--previous">Later Posts</a></div></section><footer class="footer"><p class="footer__copyright">Copyright Â© 2018 Matt Hackmann</p></footer></section></body></html>