<!DOCTYPE html>
<html><head><title>Building a Web-based Media Player - Part 1</title></head><body><article><h2>Building a Web-based Media Player - Part 1</h2><time>August 31, 2008</time><div><p>For the past month I&#39;ve been tinkering with Flex and my little Linux server. One of the projects that grew out of this was a web media player with which I could listen to all my tunes wherever there happened to be some scraps of internet. This has been one of the coolest projects I&#39;ve worked on in some time. It successfully blends nearly all of my programming skills: PHP/MySQL, Javascript, XML, Flex/Actionscript 3.0, and some C++. I&#39;m going to write a series of tutorials walking through what I&#39;ve done in hopes of bringing this coolness to the masses. I&#39;m going to be fairly verbose covering subjects that any seasoned programmer can pretty much skip over. In the first installment I&#39;m going to cover creating the database and getting song information from the MP3s.[break]</p>
<p>The first thing to do, obviously, is set up the database tables. I&#39;ve kept my setup fairly minimalistic having tables for artists, albums, and tracks. I plan to expand later to track playback habits and so forth, but these are all you need to make your player fully functional. I&#39;ve got my tables setup as follows:
<strong>artists</strong>
[list][item]id (int 4, primary key)[/item][item]name (varchar 100)[/item][/list]
<strong>albums</strong>
[list][item]id (int 4, primary key)[item][item]title (varchar 100)[/item][item]artist (int 3)[/item][/list]
<strong>tracks</strong>
[list][item]id (int 11, primary key)[/item][item]title (varchar 100)[/item][item]artist (int 4)[/item][item]album (int 4)[/item][item]track_num (int 3)[/item][item]play_count (int 5)[/item][item]date_played (int 11)[/item][/list]
Most of these fields should be self-explanitory. The tracks table can expand or contract to include what ever metadata you want (I personally left out genre as I hardly ever use that). date_played will store the Unix timestamp of the last time the song was played. I personally like storing my timestamps without formatting as to forego the unnecessary strtotime () conversion. We&#39;ll use this later when we create the recently played list.</p>
<p>About now I would begin to discuss how we&#39;re going to get this information into the database, but first we need to be able to get the information from the files. I&#39;ve got two methods for this and it all really depends on your programming skills and what you have available on your server. The first, and most available option is through Actionscript. Let&#39;s jump to code.
[code=actionscript]var tagLoader:Sound = new Sound();
tagLoader.load (&quot;my_song.mp3&quot;);
tagLoader.addEventListener (Event.ID3, tagsLoadedHandler)
tagLoader.addEventListener (Event.COMPLETE, tagsLoadedHandler)</p>
<p>function tagsLoadedHandler (e:Event):void
{
    var title:String = tagLoader.id3.title;
    var artist:String = tagLoader.id3.artist;
    var album:String = tagLoader.id3.album;
    var track:String = tagLoader.id3.track;
    // Send to database
    tagLoader.removeEventListener (Event.COMPLETE, tagsLoadedHandler);
}[/code]
[b]<em>Lines 1-2</em>[/b]
Nothing terribly exciting. We set up our Sound object which will be loading the MP3 and getting ID3 information. Immediately after we load the MP3 file _my<em>song.mp3</em> into our Sound object.
[b]<em>Lines 3-4</em>[/b]
We set up two event listeners so we can catch the data. The first fires once ID3 information has been retrieved. Depending on your MP3 file, this event won&#39;t always fire so we set up the COMPLETE event so that the code is run regardless. We&#39;ll be talking more about that in the next tutorial.
[b]<em>Lines 8-12</em>[/b]
We store the song information for temporary storage until we send it all off to the database (covered in the next tutorial).
[b]<em>Line 13</em>[/b]
We remove the event listener on the COMPLETE event. In the probable case that the ID3 event was dispatched we want the COMPLETE event removed otherwise all this code will run again adding your song to the database twice. We don&#39;t want to pull and iTunes with duplicate song issues.</p>
<p>Alright, that&#39;s the first, and slowest way to do things. I say slowest because it actually requires that the song be downloaded to your computer before it gets the information. This isn&#39;t bad if you&#39;re on a LAN connection, but it&#39;s not near as fast as using the server itself to get the information (which we&#39;ll be doing now).
[code=c++]#include <taglib/tag.h></p>
<p>#include <taglib/fileref.h></p>
<p>using namespace std;</p>
<p>void readID3 (char *fileName)
{</p>
<pre><code>TagLib::FileRef f(fileName);

cout &lt;&lt; &quot;\\t\\t&lt;album&gt;&quot; &lt;&lt; f.tag()-&gt;album() &lt;&lt; &quot;&lt;/album&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;artist&gt;&quot; &lt;&lt; f.tag()-&gt;artist() &lt;&lt; &quot;&lt;/artist&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;title&gt;&quot; &lt;&lt; f.tag()-&gt;title() &lt;&lt; &quot;&lt;/title&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;genre&gt;&quot; &lt;&lt; f.tag()-&gt;genre() &lt;&lt; &quot;&lt;/genre&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;year&gt;&quot; &lt;&lt; f.tag()-&gt;year() &lt;&lt; &quot;&lt;/year&gt;\\n&quot;;
cout &lt;&lt; &quot;\\t\\t&lt;track&gt;&quot; &lt;&lt; f.tag()-&gt;track() &lt;&lt; &quot;&lt;/track&gt;\\n&quot;;
</code></pre><p>}</p>
<p>int main (int argc, char *argv[])
{</p>
<pre><code>if (argc == 1) {
    printf (&quot;Usage --\\ntid3xml INPUT\\n&quot;);
    return 1;
}

cout &lt;&lt; &quot;&lt;?xml version=&quot;1.0&quot; ?&gt;\\n&quot;;
cout &lt;&lt; &quot;&lt;songs&gt;\\n&quot;;

for (int i = 1; i &lt; argc; i++) {
    cout &lt;&lt; &quot;\\t&lt;song file=\\&quot;&quot; &lt;&lt; argv[i] &lt;&lt; &quot;\\&quot;&gt;\\n&quot;;
    readID3 (argv[i]);
    cout &lt;&lt; &quot;\\t&lt;/song&gt;\\n&quot;;
}

cout &lt;&lt; &quot;&lt;/songs&gt;\\n&quot;;
return 0;
</code></pre><p>}[/code]
We&#39;ll be writing a small C++ program that reads ID3 information out of the MP3 file and returns XML as the output. Of course, writing the code to read ID3 tags by oneself requires some time, patience, and wading through a lot of documentation. Luckily, there are several libraries out there that will serve our purposes quite nicely. The one I have chosen is TagLib. If you&#39;re running debian getting tag lib is as simple as running:
<em>sudo apt-get install taglib-dev</em>
Now for some code:</p>
<p>I&#39;m going to skip all the includes and jump right into the meat.
[b]<em>Line 10-17</em>[/b]
This creates our TagLib object and parses the ID3 information for the file supplied to the function. This information is the output to the console.
[b]<em>Lines 25-28</em>[/b]
Checks to make sure a file was passed. If not it outputs a friendly usage guide and moves on. In actuality, since this will be later parsed by a PHP script, it would probably be a better idea to output an error code encapsulated in XML tags.
[b]<em>Lines 30-31</em>[/b]
Set up the XML file structure.
[b]<em>Lines 33-37</em>[/b]
Loop through every file passed and outputs the ID3 information for each.
[b]<em>Lines 39-40</em>[/b]
Close up and quit.
This script has a lot of obvious advantages. First of all is speed. Since it&#39;s being run on the server, where the files are kept, there is no waiting for the song to download to get the file info. Secondly, it can parse many files at one time making batch adds possible.
Well, that concludes part one of this tutorial. Next time we&#39;ll cover adding the songs to the database utilizing what was covered in this tutorial. We&#39;ll cover both scanning an existing library and a creating a front end for adding new songs. &#39;Til next time, happy coding.</p>
</div></article></body></html>